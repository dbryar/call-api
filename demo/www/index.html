<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenCALL &mdash; One Endpoint. Every Operation.</title>
  <meta name="description" content="OpenCALL is a single-endpoint, operation-based API protocol that replaces sprawling REST surfaces with one POST /call endpoint.">
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <header>
    <nav>
      <a href="#" class="logo">Open<strong>CALL</strong></a>
      <div class="nav-links">
        <a href="#problem">Problem</a>
        <a href="#answer">Answer</a>
        <a href="#try-it">Why Now</a>
        <a href="#compare">Compare</a>
        <a href="#reality">Real World</a>
        <a href="#spec">Spec</a>
        <button id="theme-toggle" type="button" aria-label="Toggle dark mode" title="Toggle dark mode">
          <span class="icon-light">&#9790;</span>
          <span class="icon-dark">&#9788;</span>
        </button>
      </div>
    </nav>
  </header>

  <main>

    <!-- Hero -->
    <section class="hero" id="hero">
      <h1>OpenCALL &mdash; Command And Lifecycle Layer</h1>
      <p class="hero-description">
        A single-endpoint, operation-based API protocol.
        Instead of dozens of routes, verbs, and status codes, every request is a
        <code>POST&nbsp;/call</code> carrying a typed operation name and its arguments.
        The server responds with a predictable envelope&mdash;every time.
      </p>
    </section>

    <!-- The Problem -->
    <section id="problem">
      <h2>The Problem</h2>
      <div class="card-grid">
        <div class="card">
          <h3>Endpoint Sprawl</h3>
          <p>
            REST APIs grow into forests of URLs. <code>/users</code>,
            <code>/users/:id/orders</code>, <code>/users/:id/orders/:oid/items</code>&mdash;each
            with its own combination of HTTP verbs, query strings, and path
            parameters. Clients need a map just to find the door.
          </p>
        </div>
        <div class="card">
          <h3>Inconsistent Errors</h3>
          <p>
            One endpoint returns <code>{"error": "not found"}</code>. Another
            returns <code>{"message": "Not Found", "code": 404}</code>. A third
            returns an HTML error page. There is no standard error envelope, so
            every integration is a special case.
          </p>
        </div>
        <div class="card">
          <h3>No Self-Description</h3>
          <p>
            REST APIs are opaque by default. Without a separately maintained
            OpenAPI spec (which is often out of date), clients have no
            machine-readable way to discover what operations exist, what
            arguments they accept, or what they return.
          </p>
        </div>
        <div class="card">
          <h3>Agents Deserve Better</h3>
          <p>
            AI agents today are forced to navigate web pages built for humans,
            burning tokens on HTML parsing, scraping forms, and guessing at
            UI flows. Developers spend weeks building translation layers
            between human-focused interfaces and agent-focused actions.
            The data is right there&mdash;behind a wall of markup.
          </p>
        </div>
      </div>

    </section>

    <!-- The Answer -->
    <section id="answer">
      <h2>The Answer</h2>
      <p>
        OpenCALL collapses every API surface into a single endpoint:
        <code>POST&nbsp;/call</code>. Each request carries an <strong>operation
        name</strong> and an <strong>arguments object</strong> inside a minimal
        JSON envelope. The server always responds with a consistent structure
        containing either a <code>result</code> or an <code>error</code>.
      </p>
      <div class="code-block-wrapper">
        <div class="code-label">Request</div>
        <pre><code>POST /call HTTP/1.1
Content-Type: application/json
Authorization: Bearer &lt;token&gt;

{
  "op": "v1:catalog.list",
  "args": {
    "type": "book",
    "limit": 10
  }
}</code></pre>
      </div>
      <p>
        Operations are namespaced, versioned, and discoverable. The server can
        describe every operation it supports&mdash;including argument schemas and
        return types&mdash;through built-in introspection, no sidecar spec needed.
      </p>
    </section>

    <!-- Yes, we know -->
    <section id="try-it">
      <figure class="xkcd-figure">
        <a href="https://xkcd.com/927/" target="_blank" rel="noopener noreferrer">
          <img src="assets/xkcd-927.png" alt="XKCD 927: Standards" width="500" height="283">
        </a>
        <figcaption>
          <a href="https://xkcd.com/927/" target="_blank" rel="noopener noreferrer">Randall Munroe / xkcd</a>, <a href="https://creativecommons.org/licenses/by-nc/2.5/" target="_blank" rel="noopener noreferrer">CC BY-NC 2.5</a>
        </figcaption>
      </figure>
      <h2>Yes, we know. But hear us out.</h2>
      <p>
        The world doesn&rsquo;t need another protocol for the sake of it. But the world
        has changed. Agents aren&rsquo;t a future concern&mdash;they&rsquo;re calling your API
        right now, and they&rsquo;re doing it by scraping HTML, parsing screenshots,
        and burning thousands of tokens just to click a button.
      </p>
      <p>
        OpenCALL gives humans and agents the same interface. One endpoint, typed
        operations, self-describing capabilities. An agent can discover what&rsquo;s
        available, call it directly, and get structured data back&mdash;no browser
        automation, no token-expensive page parsing, no translation layer between
        what the human sees and what the agent needs.
      </p>
      <p>
        Don&rsquo;t take our word for it. The demo server is live:
      </p>
      <div class="code-block-wrapper">
        <div class="code-label">curl</div>
        <pre><code>curl -X POST {{API_URL}}/call \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer demo_token" \
  -d '{"op":"v1:catalog.list","args":{"limit":5}}'</code></pre>
      </div>
      <p>Or explore the interactive playground:</p>
      <a href="{{APP_URL}}" class="btn btn-primary">Open the Demo App</a>
    </section>

    <!-- Compare -->
    <section id="compare">
      <h2>Compare</h2>
      <p>See how OpenCALL stacks up against the protocols you already know.</p>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th></th>
              <th>OpenCALL</th>
              <th>REST</th>
              <th>GraphQL</th>
              <th>gRPC</th>
              <th>JSON-RPC</th>
              <th>SOAP</th>
              <th>MCP</th>
              <th>A2A</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Endpoint pattern</strong></td>
              <td>Single <code>POST /call</code></td>
              <td>Many verb + path combos</td>
              <td>Single <code>POST /graphql</code></td>
              <td>Per-service &amp; method</td>
              <td>Single endpoint</td>
              <td>Single endpoint</td>
              <td>Single endpoint</td>
              <td>Single endpoint</td>
            </tr>
            <tr>
              <td><strong>Self-describing</strong></td>
              <td>Built-in introspection</td>
              <td>Requires OpenAPI sidecar</td>
              <td>Built-in introspection</td>
              <td>Reflection or .proto files</td>
              <td>No</td>
              <td>WSDL</td>
              <td>Yes</td>
              <td>Yes</td>
            </tr>
            <tr>
              <td><strong>Error model</strong></td>
              <td>Consistent envelope with code, message, and details</td>
              <td>Ad-hoc; varies per API</td>
              <td>Partial data + errors array</td>
              <td>Status codes + metadata</td>
              <td>Structured error object</td>
              <td>Fault element</td>
              <td>Structured</td>
              <td>Structured</td>
            </tr>
            <tr>
              <td><strong>Auth model</strong></td>
              <td>Bearer token in header; scopes per operation</td>
              <td>Varies (header, query, cookie)</td>
              <td>Varies; often context-based</td>
              <td>mTLS or token metadata</td>
              <td>Out of band</td>
              <td>WS-Security</td>
              <td>OAuth / tokens</td>
              <td>OAuth / tokens</td>
            </tr>
            <tr>
              <td><strong>Async support</strong></td>
              <td>First-class polling &amp; callbacks</td>
              <td>No standard pattern</td>
              <td>Subscriptions (WebSocket)</td>
              <td>Streaming (HTTP/2)</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
            </tr>
            <tr>
              <td><strong>Human + Agent</strong></td>
              <td>Yes</td>
              <td>Manual</td>
              <td>Manual</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
              <td>Agent only</td>
              <td>Agent only</td>
            </tr>
            <tr>
              <td><strong>Chunked results</strong></td>
              <td>Yes</td>
              <td>No</td>
              <td>No</td>
              <td>Yes (streaming)</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
            </tr>
            <tr>
              <td><strong>Caching</strong></td>
              <td>Operation-level cache hints</td>
              <td>HTTP caching (GET only)</td>
              <td>Difficult (POST-based)</td>
              <td>No built-in HTTP caching</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
              <td>No</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Reality Check -->
    <section id="reality">
      <h2>Agents in the Real World</h2>
      <p>
        We built a working demo library with full agent instructions, gave it a
        real domain, and asked ChatGPT and Claude to reserve Fahrenheit&nbsp;451.
        The results tell you exactly where the industry is right now&mdash;and
        where it&rsquo;s going fast.
      </p>

      <div class="card-grid">
        <div class="card">
          <h3>SDK agents work today</h3>
          <p>
            Agents built on frameworks like the Claude Code SDK can make HTTP requests,
            hold tokens, and call APIs directly. They read the OpenCALL instructions,
            authenticated, searched the catalog, and reserved a book&mdash;exactly as
            designed. The protocol works. The new generation of agentic tools is
            already here and growing rapidly.
          </p>
        </div>
        <div class="card">
          <h3>Browser agents can&rsquo;t POST&mdash;yet</h3>
          <p>
            Chat-based agents like ChatGPT and Claude.ai have browsing tools that
            are read-only. They understood the instructions perfectly but couldn&rsquo;t
            execute them&mdash;no POST requests, no token handling, no API calls.
            This is a temporary limitation of browser-sandboxed agents, not a
            protocol problem. It&rsquo;s already being solved by the SDK-based agents
            that developers are building right now.
          </p>
        </div>
        <div class="card">
          <h3>Safety rails need nuance</h3>
          <p>
            ChatGPT refused to authenticate on behalf of a user&mdash;even to a demo
            library with a fake card number. &ldquo;Acting on behalf of the user&rdquo;
            triggered safety guardrails that made no distinction between a banking
            API and a toy library. The guardrails are well-intentioned but blunt.
            They need a way to know when the user has genuinely said &ldquo;go ahead.&rdquo;
          </p>
        </div>
        <div class="card">
          <h3>Mandates: the missing trust layer</h3>
          <p>
            The answer is a <strong>mandate</strong>&mdash;a signed, verifiable payload
            that says &ldquo;this user authorises this agent to act on their behalf,
            with these scopes, until this time.&rdquo; Not a session cookie. Not a bearer
            token someone could have scraped. A cryptographic proof of intent that
            travels with the request. A2A protocols are heading this way, and
            OpenCALL&rsquo;s mandate envelope is next on the roadmap.
          </p>
        </div>
      </div>

      <p>
        The protocol works. The API works. SDK-based agents are using it today.
        The next frontier is the trust layer&mdash;giving browser-based agents a
        verifiable mandate so they can act with confidence, not just caution.
        Things are moving fast, and we&rsquo;re building for what&rsquo;s coming.
      </p>
    </section>

    <!-- Read the Spec -->
    <section id="spec">
      <h2>Read the Spec</h2>
      <p>
        The full OpenCALL protocol specification covers the envelope format,
        operation naming conventions, error taxonomy, authentication model,
        introspection, async patterns, and more.
      </p>
      <a href="https://github.com/dbryar/call-api/blob/main/specification.md" class="btn btn-secondary" target="_blank" rel="noopener noreferrer">
        Read the Specification &rarr;
      </a>
    </section>

    <!-- Read the Client Guide -->
    <section id="client-guide">
      <h2>Read the Client Guide</h2>
      <p>
        The client guide walks through building an OpenCALL client from scratch:
        constructing requests, handling responses, authentication, error recovery,
        and best practices for production use.
      </p>
      <a href="https://github.com/dbryar/call-api/blob/main/client.md" class="btn btn-secondary" target="_blank" rel="noopener noreferrer">
        Read the Client Guide &rarr;
      </a>
    </section>

  </main>

  <footer>
    <p>
      <a href="https://github.com/dbryar/call-api" target="_blank" rel="noopener noreferrer">GitHub</a>
      &middot; <a href="https://medium.com/@dbryar" target="_blank" rel="noopener noreferrer">Blog</a>
    </p>
  </footer>

  <script>
    (function () {
      var toggle = document.getElementById('theme-toggle');
      var root = document.documentElement;

      function getCookie(name) {
        var match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? match[2] : null;
      }

      function setCookie(name, value) {
        document.cookie = name + '=' + value + ';path=/;max-age=31536000;SameSite=Lax';
      }

      var saved = getCookie('theme');
      if (saved === 'dark' || saved === 'light') {
        root.setAttribute('data-theme', saved);
      } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        root.setAttribute('data-theme', 'dark');
      }

      toggle.addEventListener('click', function () {
        var current = root.getAttribute('data-theme');
        var next = current === 'dark' ? 'light' : 'dark';
        root.setAttribute('data-theme', next);
        setCookie('theme', next);
      });
    })();
  </script>

</body>
</html>
