# Java (Javalin) + Go (Gin) API Implementations

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add Java and Go implementations of the OpenCALL Todo API, plus a unified docker-compose that runs all four languages on separate ports.

**Architecture:** Each implementation mirrors the existing TypeScript/Python pattern — 7 modules (main, operations, router, registry, auth, state, media) with in-memory storage. The docker-compose assigns each language a unique host port (3001-3004) mapping to internal port 3000. Tests run via `API_URL=http://localhost:<port> AUTH_TOKEN=<token> bun test`.

**Tech Stack:** Java 21 + Javalin 6 + Gradle (shadow jar), Go 1.22 + Gin + gorilla/websocket

**Reference implementations:** `tests/api/typescript/src/` (canonical) and `tests/api/python/app/` (ported). Every behavioral detail matches — same error codes, same JSON field names, same HTTP status codes, same async timing.

---

## Task 1: Update docker-compose for all four languages

**Files:**
- Modify: `tests/docker/docker-compose.yml`

**Step 1: Replace docker-compose.yml with all four services**

```yaml
services:
  todo-typescript:
    build:
      context: ../api/typescript
      dockerfile: Dockerfile
    ports:
      - "3001:3000"
    environment:
      - PORT=3000
    healthcheck:
      test: ["CMD", "bun", "-e", "fetch('http://localhost:3000/.well-known/ops').then(r => process.exit(r.ok ? 0 : 1))"]
      interval: 5s
      timeout: 3s
      retries: 3

  todo-python:
    build:
      context: ../api/python
      dockerfile: Dockerfile
    ports:
      - "3002:3000"
    environment:
      - PORT=3000
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:3000/.well-known/ops')"]
      interval: 5s
      timeout: 3s
      retries: 3

  todo-java:
    build:
      context: ../api/java
      dockerfile: Dockerfile
    ports:
      - "3003:3000"
    environment:
      - PORT=3000
    healthcheck:
      test: ["CMD", "java", "-cp", "/app/app.jar", "HealthCheck"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s

  todo-go:
    build:
      context: ../api/go
      dockerfile: Dockerfile
    ports:
      - "3004:3000"
    environment:
      - PORT=3000
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/.well-known/ops"]
      interval: 5s
      timeout: 3s
      retries: 3
```

**Step 2: Verify compose file parses**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests && docker compose -f docker/docker-compose.yml config --quiet`
Expected: No output (valid YAML)

**Step 3: Commit**

```bash
git add tests/docker/docker-compose.yml
git commit -m "feat: expand docker-compose for all four language APIs"
```

---

## Task 2: Go API — project scaffolding

**Files:**
- Create: `tests/api/go/go.mod`
- Create: `tests/api/go/go.sum` (generated by `go mod tidy`)
- Create: `tests/api/go/main.go` (empty main with imports)
- Create: `tests/api/go/Dockerfile`

**Step 1: Create go.mod**

```
module opencall-todo-go

go 1.22

require (
	github.com/gin-gonic/gin v1.10.0
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.3
)
```

**Step 2: Create minimal main.go**

A minimal main that starts Gin on the configured port and has a single health endpoint.

```go
package main

import (
	"os"

	"github.com/gin-gonic/gin"
)

func main() {
	gin.SetMode(gin.ReleaseMode)
	r := gin.New()
	r.Use(gin.Recovery())

	port := os.Getenv("PORT")
	if port == "" {
		port = "3000"
	}

	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{"ok": true})
	})

	r.Run(":" + port)
}
```

**Step 3: Create Dockerfile**

```dockerfile
FROM golang:1.22-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 go build -o server .

FROM alpine:3.19

RUN apk add --no-cache wget

WORKDIR /app
COPY --from=builder /app/server .

EXPOSE 3000

CMD ["./server"]
```

**Step 4: Run go mod tidy to resolve dependencies**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go mod tidy`
Expected: `go.sum` file generated, no errors

**Step 5: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go build -o /dev/null .`
Expected: No errors

**Step 6: Commit**

```bash
git add tests/api/go/
git commit -m "feat: scaffold Go API project with Gin"
```

---

## Task 3: Go API — auth, media, state modules

**Files:**
- Create: `tests/api/go/auth.go`
- Create: `tests/api/go/media.go`
- Create: `tests/api/go/state.go`

**Step 1: Create auth.go**

Port of `tests/api/typescript/src/auth.ts`. Same logic: in-memory map of token -> scopes, `ValidateAuth` returns valid/status/code/message.

```go
package main

import "sync"

type tokenEntry struct {
	Scopes []string
}

var (
	tokenStore   = make(map[string]*tokenEntry)
	tokenStoreMu sync.RWMutex
)

func registerToken(token string, scopes []string) {
	tokenStoreMu.Lock()
	defer tokenStoreMu.Unlock()
	tokenStore[token] = &tokenEntry{Scopes: scopes}
}

func resetTokenStore() {
	tokenStoreMu.Lock()
	defer tokenStoreMu.Unlock()
	tokenStore = make(map[string]*tokenEntry)
}

type authResult struct {
	Valid   bool
	Status int
	Code   string
	Message string
}

func validateAuth(authHeader string, requiredScopes []string) authResult {
	if len(requiredScopes) == 0 {
		return authResult{Valid: true}
	}

	if len(authHeader) < 7 || authHeader[:7] != "Bearer " {
		return authResult{
			Valid:   false,
			Status:  401,
			Code:    "AUTH_REQUIRED",
			Message: "Authorization header with Bearer token is required",
		}
	}

	token := authHeader[7:]

	tokenStoreMu.RLock()
	entry, exists := tokenStore[token]
	tokenStoreMu.RUnlock()

	if !exists {
		return authResult{
			Valid:   false,
			Status:  401,
			Code:    "AUTH_REQUIRED",
			Message: "Invalid or expired token",
		}
	}

	for _, scope := range requiredScopes {
		found := false
		for _, s := range entry.Scopes {
			if s == scope {
				found = true
				break
			}
		}
		if !found {
			return authResult{
				Valid:   false,
				Status:  403,
				Code:    "INSUFFICIENT_SCOPE",
				Message: "Token lacks required scopes: " + joinScopes(requiredScopes),
			}
		}
	}

	return authResult{Valid: true}
}

func joinScopes(scopes []string) string {
	result := ""
	for i, s := range scopes {
		if i > 0 {
			result += ", "
		}
		result += s
	}
	return result
}
```

**Step 2: Create media.go**

Port of `tests/api/typescript/src/media.ts`.

```go
package main

import "sync"

var acceptedMediaTypes = []string{"image/png", "image/jpeg", "application/pdf", "text/plain"}

const maxMediaBytes = 10 * 1024 * 1024 // 10MB

type storedMedia struct {
	ID          string
	Data        []byte
	ContentType string
	Filename    string
}

var (
	mediaStore   = make(map[string]*storedMedia)
	mediaStoreMu sync.RWMutex
)

func storeMediaBlob(data []byte, contentType string, filename string) *storedMedia {
	id := newUUID()
	media := &storedMedia{ID: id, Data: data, ContentType: contentType, Filename: filename}
	mediaStoreMu.Lock()
	mediaStore[id] = media
	mediaStoreMu.Unlock()
	return media
}

func getMedia(id string) *storedMedia {
	mediaStoreMu.RLock()
	defer mediaStoreMu.RUnlock()
	return mediaStore[id]
}

func resetMedia() {
	mediaStoreMu.Lock()
	defer mediaStoreMu.Unlock()
	mediaStore = make(map[string]*storedMedia)
}
```

**Step 3: Create state.go**

Port of `tests/api/typescript/src/state.ts`. Includes `Chunk`, `OperationInstance`, `createInstance`, `transitionTo`, `getInstance`, `buildChunks` with SHA-256 checksums.

```go
package main

import (
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"strconv"
	"sync"
	"time"
)

type chunk struct {
	Offset           int     `json:"offset"`
	Data             string  `json:"data"`
	Checksum         string  `json:"checksum"`
	ChecksumPrevious *string `json:"checksumPrevious"`
	State            string  `json:"state"`
	Cursor           *string `json:"cursor"`
}

type operationInstance struct {
	RequestID    string                 `json:"requestId"`
	Op           string                 `json:"op"`
	State        string                 `json:"state"`
	Result       interface{}            `json:"result,omitempty"`
	Error        map[string]interface{} `json:"error,omitempty"`
	RetryAfterMs int                    `json:"retryAfterMs"`
	CreatedAt    string                 `json:"createdAt"`
	Chunks       []chunk                `json:"chunks,omitempty"`
}

var (
	instances   = make(map[string]*operationInstance)
	instancesMu sync.RWMutex
)

func createInstance(requestID string, op string) *operationInstance {
	inst := &operationInstance{
		RequestID:    requestID,
		Op:           op,
		State:        "accepted",
		RetryAfterMs: 100,
		CreatedAt:    time.Now().UTC().Format(time.RFC3339Nano),
	}
	instancesMu.Lock()
	instances[requestID] = inst
	instancesMu.Unlock()
	return inst
}

func transitionTo(requestID string, state string, result interface{}, err map[string]interface{}, chunks []chunk) *operationInstance {
	instancesMu.Lock()
	defer instancesMu.Unlock()
	inst, exists := instances[requestID]
	if !exists {
		return nil
	}
	inst.State = state
	if result != nil {
		inst.Result = result
	}
	if err != nil {
		inst.Error = err
	}
	if chunks != nil {
		inst.Chunks = chunks
	}
	return inst
}

func getInstance(requestID string) *operationInstance {
	instancesMu.RLock()
	defer instancesMu.RUnlock()
	return instances[requestID]
}

func resetInstances() {
	instancesMu.Lock()
	defer instancesMu.Unlock()
	instances = make(map[string]*operationInstance)
}

func computeSha256(data string) string {
	h := sha256.Sum256([]byte(data))
	return fmt.Sprintf("sha256:%x", h)
}

func buildChunks(data string, chunkSize int) []chunk {
	if chunkSize <= 0 {
		chunkSize = 512
	}
	var result []chunk
	offset := 0
	var previousChecksum *string

	for offset < len(data) {
		end := offset + chunkSize
		if end > len(data) {
			end = len(data)
		}
		chunkData := data[offset:end]
		checksum := computeSha256(chunkData)
		isLast := end >= len(data)

		var cursor *string
		state := "partial"
		if isLast {
			state = "complete"
		} else {
			c := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(end)))
			cursor = &c
		}

		result = append(result, chunk{
			Offset:           offset,
			Data:             chunkData,
			Checksum:         checksum,
			ChecksumPrevious: previousChecksum,
			State:            state,
			Cursor:           cursor,
		})

		prev := checksum
		previousChecksum = &prev
		offset = end
	}

	return result
}
```

**Step 4: Add UUID helper (used by auth, media, operations)**

Add a `newUUID()` helper to `main.go` or a `util.go`:

```go
package main

import "github.com/google/uuid"

func newUUID() string {
	return uuid.New().String()
}
```

Create this as `tests/api/go/util.go`.

**Step 5: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go build -o /dev/null .`
Expected: No errors

**Step 6: Commit**

```bash
git add tests/api/go/
git commit -m "feat(go): add auth, media, state modules"
```

---

## Task 4: Go API — operations module

**Files:**
- Create: `tests/api/go/operations.go`

**Step 1: Create operations.go**

Port of `tests/api/typescript/src/operations.ts`. This is the largest file. Key details:

- 12 operations: `todosCreate`, `todosGet`, `todosList`, `todosUpdate`, `todosDelete`, `todosComplete`, `todosExport`, `reportsGenerate`, `todosSearch`, `debugSimulateError`, `todosAttach`, `todosWatch`
- In-memory `todos` map (`map[string]map[string]interface{}`)
- Idempotency store (`map[string]interface{}`)
- Stream session management
- Validation: manual type checks (like Python), throw `ValidationError` on failure
- Error codes match exactly: `TODO_NOT_FOUND`, `MEDIA_REQUIRED`, `UNSUPPORTED_MEDIA_TYPE`, `MEDIA_TOO_LARGE`
- Async handlers use `time.AfterFunc` (Go equivalent of `setTimeout`) with 50ms delays for accepted -> pending -> complete
- Broadcast function for WebSocket events
- Cursor pagination: base64-encode offset as cursor, decode on read

The `OPERATIONS` variable is a `map[string]*operationEntry` with handler references plus metadata (`sideEffecting`, `authScopes`, `executionModel`, `deprecated`, `sunset`, `replacement`, `acceptsMedia`).

All handler functions return `map[string]interface{}` with `{"ok": true, "result": ...}` or `{"ok": false, "error": {"code": "...", "message": "..."}}`.

Validation helpers (`validateString`, `validateInt`, `validateBool`, `validateStringArray`, `validateEnum`) mirror the Python pattern — return error messages in the same format for test compatibility.

For `todosExport`: CSV format is `id,title,completed,createdAt` header plus rows with `true`/`false` (lowercase) for the boolean.

For `todosList`: when `limit` is not provided, default to 20. When `cursor` is provided, base64-decode it to get the integer offset.

**Step 2: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go build -o /dev/null .`
Expected: No errors

**Step 3: Commit**

```bash
git add tests/api/go/operations.go
git commit -m "feat(go): add operation handlers and in-memory storage"
```

---

## Task 5: Go API — registry module

**Files:**
- Create: `tests/api/go/registry.go`

**Step 1: Create registry.go**

Port of `tests/api/python/app/registry.py`. Hardcoded JSON Schema definitions for all 12 operations. Returns a Go data structure that serializes to the exact same JSON as TypeScript and Python registries.

Key: use `map[string]interface{}` for schema definitions. The `callVersion` is `"2026-02-10"`. All operation metadata (op, description, argsSchema, resultSchema, sideEffecting, idempotencyRequired, executionModel, authScopes, deprecated, sunset, replacement, mediaSchema, supportedTransports, supportedEncodings, frameSchema, ttlSeconds) must match field names exactly (camelCase in JSON).

**Step 2: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go build -o /dev/null .`

**Step 3: Commit**

```bash
git add tests/api/go/registry.go
git commit -m "feat(go): add operation registry with JSON schemas"
```

---

## Task 6: Go API — router module

**Files:**
- Create: `tests/api/go/router.go`

**Step 1: Create router.go**

Port of `tests/api/typescript/src/router.ts`. The `handleCall` function:

1. Extract `requestId` from `ctx.requestId` or generate UUID
2. Extract `sessionId` from `ctx.sessionId` (include in response if present)
3. Validate `op` field is present and a string -> 400 `INVALID_REQUEST`
4. Look up operation in `OPERATIONS` -> 400 `UNKNOWN_OP`
5. Check deprecated + sunset date -> 410 `OP_REMOVED` with `cause.removedOp` and `cause.replacement`
6. Auth check -> 401/403
7. Idempotency check for side-effecting ops with `idempotencyKey`
8. Execute handler:
   - Stream ops -> 202 with `state: "streaming"` and `stream` object
   - Async ops -> 202 with `state: "accepted"` and `retryAfterMs: 100`
   - Sync ops -> 200 with `state: "complete"` or `state: "error"` (domain errors)
9. Catch `ValidationError` -> 400 `VALIDATION_ERROR`
10. Catch `ServerError` -> use its status code
11. Catch anything else -> 500 `INTERNAL_ERROR`

Returns `map[string]interface{}` with `status` (int) and `body` (map).

**Step 2: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go build -o /dev/null .`

**Step 3: Commit**

```bash
git add tests/api/go/router.go
git commit -m "feat(go): add envelope dispatcher"
```

---

## Task 7: Go API — main.go HTTP server with all routes

**Files:**
- Modify: `tests/api/go/main.go`

**Step 1: Replace main.go with full server**

Wire all routes using Gin:

- `GET /.well-known/ops` — serve registry JSON with ETag and Cache-Control. Support `If-None-Match` -> 304.
- `POST /call` — parse JSON or multipart/form-data. For multipart: read `envelope` field (JSON string) and optional `file` field. Call `handleCall`. Return JSON response with status code.
- `GET /ops/:requestId` — poll async operation state.
- `GET /ops/:requestId/chunks` — chunked retrieval with cursor query param. Base64-decode cursor to get offset.
- `GET /media/:id` — 303 redirect to `/media/:id/data`.
- `GET /media/:id/data` — serve binary with Content-Type and Content-Disposition.
- `WebSocket /streams/:sessionId` — upgrade to WebSocket using gorilla/websocket. Register connection for broadcasts.
- `POST /_internal/tokens` — register auth tokens.

On startup: call `resetStorage()`, `resetTokenStore()`, `resetInstances()`, `resetMedia()`, `resetStreamSessions()`. Build registry once, compute ETag (SHA-256 of JSON bytes).

WebSocket: use `gorilla/websocket.Upgrader` with `CheckOrigin: func(r *http.Request) bool { return true }`. Track active connections in a sync.Map or slice. Broadcast function sends JSON to all active connections.

**Step 2: Verify it compiles and starts**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/go && go build -o /tmp/go-server . && /tmp/go-server &`
Then: `curl http://localhost:3000/.well-known/ops | head -c 200`
Expected: JSON registry response
Then: `kill %1`

**Step 3: Commit**

```bash
git add tests/api/go/main.go
git commit -m "feat(go): wire all routes in main server"
```

---

## Task 8: Go API — Docker build and test

**Step 1: Build the Go Docker image**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests && docker compose -f docker/docker-compose.yml build todo-go`
Expected: Successful build

**Step 2: Start the Go container**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests && docker compose -f docker/docker-compose.yml up -d todo-go`
Expected: Container starts, health check passes

**Step 3: Register a token and run tests**

```bash
curl -s -X POST http://localhost:3004/_internal/tokens \
  -H "Content-Type: application/json" \
  -d '{"token":"test-token","scopes":["todos:read","todos:write","reports:read"]}'

cd /Users/daniel.bryar/nexus/not-rest/tests
API_URL=http://localhost:3004 AUTH_TOKEN=test-token bun test
```

Expected: All 112 tests pass

**Step 4: Debug any failures**

If tests fail, read the error output carefully. Common issues:
- JSON field name casing (Go defaults to lowercase; use `json:"fieldName"` struct tags)
- Null vs absent fields (use `*string` with `omitempty` for optional nullable fields, but `completedAt` must be `null` not absent)
- Base64 encoding differences (Go uses standard base64, match `btoa`/`atob` which is also standard)
- Boolean serialization in CSV export (`true`/`false` lowercase)
- Validation error message format must match
- The `deprecated` op sunset date `2025-01-01` is in the past, so it should return 410

**Step 5: Stop container and commit**

```bash
docker compose -f docker/docker-compose.yml down
git add tests/api/go/
git commit -m "feat(go): complete Go/Gin API — all 112 tests passing"
```

---

## Task 9: Java API — project scaffolding

**Files:**
- Create: `tests/api/java/build.gradle`
- Create: `tests/api/java/settings.gradle`
- Create: `tests/api/java/src/main/java/opencall/App.java`
- Create: `tests/api/java/Dockerfile`

**Step 1: Create build.gradle**

```gradle
plugins {
    id 'java'
    id 'application'
    id 'com.gradleup.shadow' version '9.0.0-beta4'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    mainClass = 'opencall.App'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'io.javalin:javalin:6.4.0'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.18.2'
    implementation 'org.slf4j:slf4j-simple:2.0.16'
}

shadowJar {
    archiveBaseName = 'app'
    archiveClassifier = ''
    archiveVersion = ''
    mergeServiceFiles()
}
```

**Step 2: Create settings.gradle**

```gradle
rootProject.name = 'opencall-todo-java'
```

**Step 3: Create minimal App.java**

```java
package opencall;

import io.javalin.Javalin;

public class App {
    public static void main(String[] args) {
        int port = Integer.parseInt(System.getenv().getOrDefault("PORT", "3000"));

        Javalin app = Javalin.create()
            .get("/health", ctx -> ctx.json(java.util.Map.of("ok", true)))
            .start(port);
    }
}
```

**Step 4: Create Dockerfile**

```dockerfile
FROM gradle:8.12-jdk21 AS builder

WORKDIR /app

COPY build.gradle settings.gradle ./
COPY src/ src/

RUN gradle shadowJar --no-daemon

FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

COPY --from=builder /app/build/libs/app.jar app.jar

EXPOSE 3000

CMD ["java", "-jar", "app.jar"]
```

**Step 5: Verify Gradle build works**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/java && gradle shadowJar --no-daemon`
Expected: BUILD SUCCESSFUL, `build/libs/app.jar` created

Note: If gradle is not installed locally, use Docker: `docker run --rm -v "$(pwd)":/app -w /app gradle:8.12-jdk21 gradle shadowJar --no-daemon`

**Step 6: Commit**

```bash
git add tests/api/java/
git commit -m "feat: scaffold Java API project with Javalin"
```

---

## Task 10: Java API — auth, media, state classes

**Files:**
- Create: `tests/api/java/src/main/java/opencall/Auth.java`
- Create: `tests/api/java/src/main/java/opencall/Media.java`
- Create: `tests/api/java/src/main/java/opencall/State.java`

**Step 1: Create Auth.java**

Port of `tests/api/typescript/src/auth.ts`. Same pattern as Go — in-memory `ConcurrentHashMap<String, List<String>>`, `registerToken`, `resetTokenStore`, `validateAuth` returns an `AuthResult` record.

```java
package opencall;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Auth {
    private static final Map<String, List<String>> tokenStore = new ConcurrentHashMap<>();

    public record AuthResult(boolean valid, int status, String code, String message) {
        public static AuthResult ok() { return new AuthResult(true, 0, null, null); }
    }

    public static void registerToken(String token, List<String> scopes) {
        tokenStore.put(token, new ArrayList<>(scopes));
    }

    public static void resetTokenStore() {
        tokenStore.clear();
    }

    public static AuthResult validateAuth(String authHeader, List<String> requiredScopes) {
        if (requiredScopes == null || requiredScopes.isEmpty()) {
            return AuthResult.ok();
        }

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return new AuthResult(false, 401, "AUTH_REQUIRED",
                "Authorization header with Bearer token is required");
        }

        String token = authHeader.substring(7);
        List<String> scopes = tokenStore.get(token);

        if (scopes == null) {
            return new AuthResult(false, 401, "AUTH_REQUIRED",
                "Invalid or expired token");
        }

        for (String required : requiredScopes) {
            if (!scopes.contains(required)) {
                return new AuthResult(false, 403, "INSUFFICIENT_SCOPE",
                    "Token lacks required scopes: " + String.join(", ", requiredScopes));
            }
        }

        return AuthResult.ok();
    }
}
```

**Step 2: Create Media.java**

```java
package opencall;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Media {
    public static final List<String> ACCEPTED_MEDIA_TYPES = List.of(
        "image/png", "image/jpeg", "application/pdf", "text/plain"
    );
    public static final int MAX_MEDIA_BYTES = 10 * 1024 * 1024;

    public record StoredMedia(String id, byte[] data, String contentType, String filename) {}

    private static final Map<String, StoredMedia> mediaStore = new ConcurrentHashMap<>();

    public static StoredMedia storeMedia(byte[] data, String contentType, String filename) {
        String id = UUID.randomUUID().toString();
        StoredMedia media = new StoredMedia(id, data, contentType, filename);
        mediaStore.put(id, media);
        return media;
    }

    public static StoredMedia getMedia(String id) {
        return mediaStore.get(id);
    }

    public static void resetMedia() {
        mediaStore.clear();
    }
}
```

**Step 3: Create State.java**

Port of `tests/api/typescript/src/state.ts`. Includes `Chunk` record, `OperationInstance` class, `createInstance`, `transitionTo`, `getInstance`, `computeSha256`, `buildChunks`.

SHA-256 via `java.security.MessageDigest`. Base64 via `java.util.Base64`.

```java
package opencall;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class State {
    public record Chunk(int offset, String data, String checksum, String checksumPrevious,
                        String state, String cursor) {
        public Map<String, Object> toMap() {
            var m = new LinkedHashMap<String, Object>();
            m.put("offset", offset);
            m.put("data", data);
            m.put("checksum", checksum);
            m.put("checksumPrevious", checksumPrevious);
            m.put("state", state);
            m.put("cursor", cursor);
            return m;
        }
    }

    public static class OperationInstance {
        public String requestId;
        public String op;
        public String state = "accepted";
        public Object result;
        public Map<String, Object> error;
        public int retryAfterMs = 100;
        public String createdAt;
        public List<Chunk> chunks;

        public OperationInstance(String requestId, String op) {
            this.requestId = requestId;
            this.op = op;
            this.createdAt = Instant.now().toString();
        }
    }

    private static final Map<String, OperationInstance> instances = new ConcurrentHashMap<>();

    public static OperationInstance createInstance(String requestId, String op) {
        OperationInstance inst = new OperationInstance(requestId, op);
        instances.put(requestId, inst);
        return inst;
    }

    public static OperationInstance transitionTo(String requestId, String state,
                                                   Object result, Map<String, Object> error,
                                                   List<Chunk> chunks) {
        OperationInstance inst = instances.get(requestId);
        if (inst == null) return null;
        inst.state = state;
        if (result != null) inst.result = result;
        if (error != null) inst.error = error;
        if (chunks != null) inst.chunks = chunks;
        return inst;
    }

    public static OperationInstance getInstance(String requestId) {
        return instances.get(requestId);
    }

    public static void resetInstances() {
        instances.clear();
    }

    public static String computeSha256(String data) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(data.getBytes(StandardCharsets.UTF_8));
            StringBuilder hex = new StringBuilder();
            for (byte b : hash) hex.append(String.format("%02x", b));
            return "sha256:" + hex;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static List<Chunk> buildChunks(String data, int chunkSize) {
        if (chunkSize <= 0) chunkSize = 512;
        List<Chunk> result = new ArrayList<>();
        int offset = 0;
        String previousChecksum = null;

        while (offset < data.length()) {
            int end = Math.min(offset + chunkSize, data.length());
            String chunkData = data.substring(offset, end);
            String checksum = computeSha256(chunkData);
            boolean isLast = end >= data.length();

            String cursor = isLast ? null :
                Base64.getEncoder().encodeToString(String.valueOf(end).getBytes(StandardCharsets.UTF_8));
            String chunkState = isLast ? "complete" : "partial";

            result.add(new Chunk(offset, chunkData, checksum, previousChecksum, chunkState, cursor));
            previousChecksum = checksum;
            offset = end;
        }

        return result;
    }
}
```

**Step 4: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/java && gradle compileJava --no-daemon`
Expected: BUILD SUCCESSFUL

**Step 5: Commit**

```bash
git add tests/api/java/src/
git commit -m "feat(java): add auth, media, state classes"
```

---

## Task 11: Java API — operations class

**Files:**
- Create: `tests/api/java/src/main/java/opencall/Operations.java`

**Step 1: Create Operations.java**

Port of `tests/api/typescript/src/operations.ts`. Same pattern as Go/Python.

Key Java-specific details:
- `ConcurrentHashMap<String, Map<String, Object>>` for todos store
- `ConcurrentHashMap<String, Object>` for idempotency store
- `ValidationError` and `ServerError` as custom exceptions
- Validation helpers: `validateString`, `validateInt`, `validateBool`, `validateStringArray`, `validateEnum`
- All handlers return `Map<String, Object>` with `ok` boolean + `result` or `error`
- Async handlers use `java.util.Timer` or `CompletableFuture.delayedExecutor` with 50ms delays
- `OperationEntry` record/class with handler, asyncHandler, streamHandler, sideEffecting, authScopes, executionModel, deprecated, sunset, replacement, acceptsMedia
- `OPERATIONS` is a `Map<String, OperationEntry>`
- CSV export: `true`/`false` lowercase for booleans
- When checking `instanceof Boolean` for int validation, reject booleans (Java auto-unboxes, but Jackson maps JSON booleans to Boolean)

Jackson will deserialize JSON into `Map<String, Object>` where numbers become `Integer` or `Double`. Handle both in `validateInt`.

**Step 2: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/java && gradle compileJava --no-daemon`

**Step 3: Commit**

```bash
git add tests/api/java/src/main/java/opencall/Operations.java
git commit -m "feat(java): add operation handlers and in-memory storage"
```

---

## Task 12: Java API — registry class

**Files:**
- Create: `tests/api/java/src/main/java/opencall/Registry.java`

**Step 1: Create Registry.java**

Port of `tests/api/python/app/registry.py`. Hardcoded JSON Schema as nested `Map<String, Object>` / `LinkedHashMap` structures. Returns the registry as a `Map` that Jackson serializes to JSON.

Use `LinkedHashMap` to preserve key ordering (not strictly required by tests, but cleaner).

**Step 2: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/java && gradle compileJava --no-daemon`

**Step 3: Commit**

```bash
git add tests/api/java/src/main/java/opencall/Registry.java
git commit -m "feat(java): add operation registry with JSON schemas"
```

---

## Task 13: Java API — router class

**Files:**
- Create: `tests/api/java/src/main/java/opencall/Router.java`

**Step 1: Create Router.java**

Port of `tests/api/typescript/src/router.ts`. Same dispatch logic as Go router.

The `handleCall` method takes the envelope (as `Map<String, Object>`), auth header string, and optional media file map. Returns `Map<String, Object>` with `status` and `body`.

Use Jackson `ObjectMapper` for any JSON parsing within the router (envelope is already deserialized by the time it gets here).

**Step 2: Verify it compiles**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/java && gradle compileJava --no-daemon`

**Step 3: Commit**

```bash
git add tests/api/java/src/main/java/opencall/Router.java
git commit -m "feat(java): add envelope dispatcher"
```

---

## Task 14: Java API — App.java HTTP server with all routes

**Files:**
- Modify: `tests/api/java/src/main/java/opencall/App.java`

**Step 1: Replace App.java with full server**

Wire all routes using Javalin:

- `GET /.well-known/ops` — serve registry JSON with ETag and Cache-Control. Support `If-None-Match` -> 304.
- `POST /call` — check Content-Type. For `multipart/form-data`: read `envelope` form field and optional `file` upload. For JSON: parse body. Call `Router.handleCall`. Return JSON with status.
- `GET /ops/{requestId}` — poll async operation.
- `GET /ops/{requestId}/chunks` — chunked retrieval with cursor query param.
- `GET /media/{id}` — 303 redirect.
- `GET /media/{id}/data` — binary response.
- `WS /streams/{sessionId}` — WebSocket via Javalin's `ws()` handler. Track connections, broadcast to all.
- `POST /_internal/tokens` — register tokens.

On startup: reset all stores, build registry, compute ETag.

Javalin WebSocket: use `app.ws("/streams/{sessionId}", ws -> { ws.onConnect(...); ws.onClose(...); })`. Track `WsContext` objects in a `Set`. Broadcast sends JSON string to all.

Jackson `ObjectMapper` for JSON serialization. Configure to not fail on unknown properties and to exclude null values where appropriate.

Key Javalin details:
- `ctx.status(303).header("Location", ...)` for redirect
- `ctx.result(bytes).contentType(...)` for binary response
- `ctx.uploadedFile("file")` for multipart file
- `ctx.formParam("envelope")` for multipart envelope text

**Step 2: Verify it compiles and starts**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests/api/java && gradle shadowJar --no-daemon && java -jar build/libs/app.jar &`
Then: `curl http://localhost:3000/.well-known/ops | head -c 200`
Expected: JSON registry response
Then: `kill %1`

**Step 3: Commit**

```bash
git add tests/api/java/src/main/java/opencall/App.java
git commit -m "feat(java): wire all routes in main server"
```

---

## Task 15: Java API — Docker build and test

**Step 1: Build the Java Docker image**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests && docker compose -f docker/docker-compose.yml build todo-java`
Expected: Successful build (may take a few minutes for Gradle)

**Step 2: Start the Java container**

Run: `cd /Users/daniel.bryar/nexus/not-rest/tests && docker compose -f docker/docker-compose.yml up -d todo-java`
Expected: Container starts, health check passes

**Step 3: Register a token and run tests**

```bash
curl -s -X POST http://localhost:3003/_internal/tokens \
  -H "Content-Type: application/json" \
  -d '{"token":"test-token","scopes":["todos:read","todos:write","reports:read"]}'

cd /Users/daniel.bryar/nexus/not-rest/tests
API_URL=http://localhost:3003 AUTH_TOKEN=test-token bun test
```

Expected: All 112 tests pass

**Step 4: Debug any failures**

Common Java issues:
- Jackson serializes `null` by default; some fields should be absent, not null. Use `@JsonInclude(Include.NON_NULL)` or filter nulls from maps.
- `Integer` vs `Long` — Jackson may deserialize JSON integers as `Integer`; be careful with type checks.
- Thread safety in async handlers — use `Timer` or `ScheduledExecutorService` with daemon threads.
- WebSocket: Javalin's WS API uses `WsContext`, not raw `WebSocket`. Make sure broadcast function sends to all tracked `WsContext` objects.
- Multipart: Javalin's `ctx.formParam("envelope")` returns the text value; `ctx.uploadedFile("file")` returns an `UploadedFile`.

**Step 5: Stop container and commit**

```bash
docker compose -f docker/docker-compose.yml down
git add tests/api/java/
git commit -m "feat(java): complete Java/Javalin API — all 112 tests passing"
```

---

## Task 16: Full integration test — all four languages via Docker

**Step 1: Build and start all containers**

```bash
cd /Users/daniel.bryar/nexus/not-rest/tests
docker compose -f docker/docker-compose.yml up --build -d
docker compose -f docker/docker-compose.yml ps  # verify all healthy
```

**Step 2: Register tokens for all external servers**

```bash
for port in 3001 3002 3003 3004; do
  curl -s -X POST http://localhost:$port/_internal/tokens \
    -H "Content-Type: application/json" \
    -d '{"token":"test-token","scopes":["todos:read","todos:write","reports:read"]}'
done
```

**Step 3: Run tests against each language**

```bash
cd /Users/daniel.bryar/nexus/not-rest/tests

echo "=== TypeScript ==="
API_URL=http://localhost:3001 AUTH_TOKEN=test-token bun test

echo "=== Python ==="
API_URL=http://localhost:3002 AUTH_TOKEN=test-token bun test

echo "=== Java ==="
API_URL=http://localhost:3003 AUTH_TOKEN=test-token bun test

echo "=== Go ==="
API_URL=http://localhost:3004 AUTH_TOKEN=test-token bun test
```

Expected: All 112 tests pass for all four languages (448 total test runs)

**Step 4: Clean up**

```bash
docker compose -f docker/docker-compose.yml down
```

**Step 5: Commit**

No code changes in this task — just verification.

---

## Task 17: Update README and docs

**Files:**
- Modify: `tests/README.md`

**Step 1: Update README.md**

Add Java and Go sections to the README:
- Add to the folder structure diagram
- Add Java and Go quick-start examples (similar to the Python section)
- Update Docker section to show all four ports
- Update the language list

**Step 2: Commit**

```bash
git add tests/README.md
git commit -m "docs: update README with Java and Go API instructions"
```

---

## Important implementation notes for the engineer

### JSON null vs absent

The tests check for specific JSON shapes. Key rules:
- `completedAt` must be `null` (not absent) when a todo is not completed
- Optional fields like `description`, `dueDate`, `labels` should be **absent** when not provided
- `cursor` in list results is `null` (not absent) when there's no next page
- `checksumPrevious` in chunks is `null` (not absent) for the first chunk

### Validation error messages

The tests check exact error code strings but not exact messages. Error codes that must match exactly:
- `INVALID_REQUEST`, `UNKNOWN_OP`, `VALIDATION_ERROR`, `OP_REMOVED`
- `AUTH_REQUIRED`, `INSUFFICIENT_SCOPE`
- `TODO_NOT_FOUND`, `MEDIA_REQUIRED`, `UNSUPPORTED_MEDIA_TYPE`, `MEDIA_TOO_LARGE`
- `NOT_FOUND`, `NOT_READY`, `INTERNAL_ERROR`
- `SIMULATED_ERROR` (default for debug.simulateError)

### Async timing

The async handlers (export, report) must transition through states:
1. Return 202 immediately with `state: "accepted"`
2. After ~50ms, transition to `"pending"`
3. After another ~50ms, transition to `"complete"` with result

The tests poll with `retryAfterMs` so the exact timing isn't critical, but the state machine must progress.

### WebSocket broadcast

When a todo is created/updated/deleted/completed, broadcast to all active WebSocket connections. The broadcast payload matches the `WatchTodosFrameSchema`:
```json
{"event": "created", "todo": {...}, "timestamp": "..."}
{"event": "updated", "todo": {...}, "timestamp": "..."}
{"event": "deleted", "todoId": "...", "timestamp": "..."}
{"event": "completed", "todo": {...}, "timestamp": "..."}
```

### Docker healthcheck for Java

Java's JVM startup is slower. The docker-compose uses `start_period: 10s` and `retries: 5` for the Java service. The healthcheck uses `wget` (available in alpine) instead of a Java class to avoid the overhead of starting another JVM.

Update the Java healthcheck in docker-compose to use wget instead of the Java class suggested earlier:
```yaml
healthcheck:
  test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/.well-known/ops"]
  interval: 5s
  timeout: 5s
  retries: 5
  start_period: 10s
```
